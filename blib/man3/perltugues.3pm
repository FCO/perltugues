.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "perltugues 3"
.TH perltugues 3 "2009-06-28" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "VERSION"
.IX Header "VERSION"
0.16
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use perltugues;
.Ve
.PP
.Vb 3
\&    inteiro: i, j;
\&    texto: k;
\&    inteiro: l;
.Ve
.PP
.Vb 6
\&    para i (de 1 a 100 a cada 5) {
\&       escreva i, quebra de linha;
\&       k = "lalala";
\&       escreva k, quebra de linha;
\&       escreva j, quebra de linha;
\&    }
.Ve
.PP
.Vb 3
\&    enquanto(i >= j){
\&       escreva \(aqi e j => \(aq, i, " >= ", j++, quebra de linha;
\&    }
.Ve
.PP
.Vb 1
\&    escreva quebra de linha;
.Ve
.PP
.Vb 1
\&    escreva de 0 a 50 a cada 10, quebra de linha;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Perltugues\*(C'\fR é uma forma facil de se aprender algoritmo. Com ele você tem uma \*(L"linguagem\*(R" (quase) completa em português, o que facilita muito a aprendizagempor pseudocódigo. E a transição para o \f(CW\*(C`perl\*(C'\fR é muito simples.
.Sh "Declarações"
.IX Subsection "Declarações"
Declarações em \f(CW\*(C`Perltugues\*(C'\fR são separadas por ponto\-e\-vírgula (\f(CW\*(C`;\*(C'\fR)
.Sh "Blocos"
.IX Subsection "Blocos"
Podemos criar blocos com chaves:
.PP
.Vb 3
\&  {
\&          ...
\&  }
.Ve
.PP
ou com declarações de início e fim:
.PP
.Vb 3
\&  inicio:
\&      ...
\&  fim
.Ve
.PP
O sinal de dois pontos (\f(CW\*(C`:\*(C'\fR) antes de \*(L"inicio\*(R" é opcional.
.Sh "Variáveis"
.IX Subsection "Variáveis"
Todos os nomes de variáveis em \f(CW\*(C`perltugues\*(C'\fR devem começar com uma letra (/^[a\-zA\-Z]/). Existem quatro tipos de variáveis que podem ser usados:
.PP
\fIcaractere\fR
.IX Subsection "caractere"
.PP
Armazena um único caractere.
.PP
\fItexto\fR
.IX Subsection "texto"
.PP
Armazena uma sequência (string) de caracteres, de qualquer tamanho.
.PP
\fIinteiro\fR
.IX Subsection "inteiro"
.PP
Armazena números inteiros.
.PP
\fIreal\fR
.IX Subsection "real"
.PP
Armazena números reais (ponto flutuante).
.PP
\fIDeclaração de variáveis\fR
.IX Subsection "Declaração de variáveis"
.PP
Variáveis são declaradas da seguinte forma:
.PP
.Vb 2
\&    inteiro: i;
\&    inteiro: j;
.Ve
.PP
.Vb 1
\&    inteiro: i, j;
.Ve
.PP
.Vb 1
\&    texto: str;
.Ve
.PP
.Vb 1
\&    caractere: chr1, chr2;
.Ve
.Sh "Entrada e Saída"
.IX Subsection "Entrada e Saída"
\fIescreve =head3 escreva\fR
.IX Subsection "escreve =head3 escreva"
.PP
\fIleia\fR
.IX Subsection "leia"
.Sh "Estruturas condicionais"
.IX Subsection "Estruturas condicionais"
\fIse\fR
.IX Subsection "se"
.PP
.Vb 3
\&   se a > b {
\&           ...
\&   }
.Ve
.PP
Executa o bloco apenas se a expressão fornecida for verdadeira. Note que, em qualquer estrutura do \f(CW\*(C`perltugues\*(C'\fR, parêntesis envolvendo a expressão são opcionais (i.e., no exemplo acima, as expressões \f(CW\*(C`a > b\*(C'\fR e \f(CW\*(C`(a > b)\*(C'\fR são aceitas da mesma forma.
.PP
\fIa não ser que =head3 a nao ser que\fR
.IX Subsection "a não ser que =head3 a nao ser que"
.PP
.Vb 1
\&   TODO
.Ve
.Sh "Estruturas de Iteração (laços):"
.IX Subsection "Estruturas de Iteração (laços):"
\fIpara\fR
.IX Subsection "para"
.PP
A estrutura \f(CW\*(C`para\*(C'\fR atribui a uma variável a sequência de valores definida. Por exemplo, o trecho de código:
.PP
.Vb 3
\&    para i (de 1 a 10) {
\&        ...
\&    }
.Ve
.PP
realizará o bloco entre chaves 10 vezes e, para cada vez, atribuirá o valor à variável determinada (no caso, \f(CW\*(C`i\*(C'\fR).
.PP
Nessa construção é possivel ainda utilizar a expressão 'a cada X', onde X indica quantos elementos serão pulados a cada iteração. Por exemplo:
.PP
.Vb 3
\&   para i de 1 a 10 a cada 2 {
\&           ...
\&   }
.Ve
.PP
executará com os valores 1, 3, 5, 7 e 9. 
.PP
\fIenquanto\fR
.IX Subsection "enquanto"
.PP
.Vb 3
\&    enquanto i != j {
\&        ...
\&    }
.Ve
.PP
Executa o bloco enquanto a expressão definida for verdadeira.
.PP
\fIateh que =head3 até que =head3 ate que\fR
.IX Subsection "ateh que =head3 até que =head3 ate que"
.PP
.Vb 3
\&    ateh que i == j {
\&        ...
\&    }
.Ve
.PP
Executa o bloco até que a expressão fornecida seja verdadeira. Note que o \*(L"que\*(R" é opcional, então:
.PP
.Vb 3
\&    até (i == j) {
\&                ...
\&        }
.Ve
.PP
produz o mesmo resultado que o exemplo anterior. Para facilitar ainda mais a legibilidade de seus algoritmos, é possível usar apenas o 'q' como um sinônimo para 'que'. As mesmas regras do 'que' valem para todas as expressões do \f(CW\*(C`perltugues\*(C'\fR que a utilize em sua sintaxe.
.PP
\fIcontrolando o fluxo de seus laços\fR
.IX Subsection "controlando o fluxo de seus laços"
.PP
Algumas expressões podem ser usadas para controlar o fluxo dos laços. Em casos de laços aninhados, elas serão aplicadas sempre em relação ao laço mais específico. Para tratar laços externos, é possível rotulá\-los e referenciar o rótulo. As expressões são:
.PP
saia do laço =head4 saia do laco =head4 saia do loop
.IX Subsection "saia do laço =head4 saia do laco =head4 saia do loop"
.PP
sai do laço completamente.
.PP
próximo =head4 proximo
.IX Subsection "próximo =head4 proximo"
.PP
inicia a próxima iteração no laço.
.PP
de novo =head4 refaça =head4 refaca
.IX Subsection "de novo =head4 refaça =head4 refaca"
.PP
executa novamente o laço, mas sem reavaliar a condição.
.PP
.Vb 5
\&   enquanto (CONDICAO) {  # <\-\- "próximo" vem para cá
\&      # <\-\- "de novo" vem para cá
\&      ...
\&   }
\&   # <\-\- "saia do laço" vem para cá
.Ve
.PP
vá para \s-1ROTULO\s0 =head4 va para \s-1ROTULO\s0
.IX Subsection "vá para ROTULO =head4 va para ROTULO"
.PP
posiciona o fluxo do seu código em um local arbitrário do mesmo, definido a partir de um rótulo.
.PP
.Vb 3
\&  INICIO: 
\&  ...
\&  vá para INICIO;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Fernando Correa de Oliveira <fco@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Breno G. de Oliveira
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2008 Fernanco Correa de Oliveira \f(CW\*(C`<fco at cpan.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself. See perlartistic.
